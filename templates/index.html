<!DOCTYPE html>
<html lang="zh-TW">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Gridworld Visualization</title>
        <!-- Flask Ê≠£Á¢∫ËºâÂÖ• CSS -->
        <link
            rel="stylesheet"
            href="{{ url_for('static', filename='styles.css') }}"
        />
    </head>
    <body>
        <!-- Title Section -->
        <div class="header">Gridworld Visualization</div>

        <!-- Navigation Bar -->
        <div class="nav-bar">
            <button onclick="switchSection('introduction')">
                Introduction
            </button>
            <button onclick="switchSection('demo')">Demo</button>
        </div>

        <!-- Introduction Page -->
        <div id="introduction" class="section active">
            <div class="intro-content">
                <h2>üîç Introduction to Gridworld & Value Iteration</h2>
                <p>
                    The <strong>Gridworld Environment</strong> is a simplified
                    reinforcement learning environment where an agent navigates
                    a grid to reach the goal while avoiding obstacles.
                </p>
                <p>
                    <strong>Value Iteration</strong> is an algorithm used in
                    reinforcement learning to compute the optimal policy by
                    iteratively updating the value of each state.
                </p>

                <h3>üìå How to Use the Demo:</h3>
                <ul>
                    <li>Choose the grid size (5x5 to 9x9).</li>
                    <li>
                        Click on a cell to set the
                        <strong>start position (üü©)</strong>.
                    </li>
                    <li>
                        Click another cell to set the
                        <strong>goal position (üü•)</strong>.
                    </li>
                    <li>Add up to <strong>n-2 obstacles (‚¨õ)</strong>.</li>
                    <li>
                        Click "Compute Value Evaluation" to see the results!
                    </li>
                </ul>
            </div>
        </div>

        <!-- Demo Page -->
        <div id="demo" class="section">
            <h2>üîß Gridworld Demo</h2>

            <label for="size">Choose Grid Size (5-9):</label>
            <input type="number" id="size" min="5" max="9" value="5" />
            <button onclick="generateGrid()">Generate Grid</button>

            <div id="gridContainer" class="grid"></div>
            <button onclick="evaluateValues()">Compute Value Evaluation</button>

            <!-- Results Section -->
            <div id="resultsSection" class="results">
                <div class="grid-container">
                    <div class="grid-box">
                        <h2>Path Animation</h2>
                        <div id="pathGrid" class="grid"></div>
                    </div>
                    <div class="grid-box">
                        <h2>Policy Arrows</h2>
                        <div id="policyGrid" class="grid"></div>
                    </div>
                    <div class="grid-box">
                        <h2>Value (V)</h2>
                        <div id="valueGrid" class="grid"></div>
                    </div>
                </div>
            </div>
        </div>

        <script>
            let gridSize = 5;
            let gridData = [];
            let obstacleCount = 0;
            let maxObstacles = 3;

            function switchSection(section) {
                document
                    .querySelectorAll(".section")
                    .forEach((sec) => sec.classList.remove("active"));
                document.getElementById(section).classList.add("active");
            }

            function generateGrid() {
                // Get grid size from user input
                gridSize = parseInt(document.getElementById("size").value);
                maxObstacles = gridSize - 2;
                obstacleCount = 0;
                gridData = Array.from({ length: gridSize }, () =>
                    Array(gridSize).fill("empty")
                );

                const gridContainer = document.getElementById("gridContainer");
                gridContainer.innerHTML = ""; // Clear previous grid
                gridContainer.style.gridTemplateColumns = `repeat(${gridSize}, 50px)`;
                gridContainer.style.gridTemplateRows = `repeat(${gridSize}, 50px)`;

                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        let cell = document.createElement("div");
                        cell.classList.add("cell");
                        cell.dataset.row = i;
                        cell.dataset.col = j;
                        cell.onclick = () => cellClicked(i, j, cell);
                        gridContainer.appendChild(cell);
                    }
                }

                // Hide results section when regenerating the grid
                document.getElementById("resultsSection").style.display =
                    "none";
            }

            function cellClicked(row, col, cell) {
                if (gridData[row][col] === "empty") {
                    if (!gridData.flat().includes("start")) {
                        cell.classList.add("start");
                        gridData[row][col] = "start";
                    } else if (!gridData.flat().includes("goal")) {
                        cell.classList.add("goal");
                        gridData[row][col] = "goal";
                    } else if (obstacleCount < maxObstacles) {
                        cell.classList.add("obstacle");
                        gridData[row][col] = "obstacle";
                        obstacleCount++;
                    }
                }
            }

            function evaluateValues() {
                fetch("/evaluate", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ grid: gridData, size: gridSize }),
                })
                    .then((response) => response.json())
                    .then((data) => {
                        drawGrid("policyGrid", data.policy);
                        drawGrid("valueGrid", data.values, true);
                        animatePath(data.path);

                        // Show the results section
                        document.getElementById(
                            "resultsSection"
                        ).style.display = "block";
                    });
            }

            function drawGrid(gridId, data, isValue = false) {
                const gridContainer = document.getElementById(gridId);
                gridContainer.innerHTML = "";
                gridContainer.style.gridTemplateColumns = `repeat(${gridSize}, 50px)`;

                for (let i = 0; i < gridSize; i++) {
                    for (let j = 0; j < gridSize; j++) {
                        let cell = document.createElement("div");
                        cell.classList.add("cell");
                        if (gridData[i][j] === "start")
                            cell.classList.add("start");
                        if (gridData[i][j] === "goal")
                            cell.classList.add("goal");
                        if (gridData[i][j] === "obstacle")
                            cell.classList.add("obstacle");

                        if (gridData[i][j] === "empty") {
                            let text = document.createElement("div");
                            text.innerText = isValue
                                ? data[i][j].toFixed(2)
                                : getArrowSymbol(data[i][j]);
                            cell.appendChild(text);
                        }
                        gridContainer.appendChild(cell);
                    }
                }
            }

            function animatePath(path) {
                let step = 0;
                const pathGrid = document.getElementById("pathGrid");
                pathGrid.innerHTML = "";
                pathGrid.style.gridTemplateColumns = `repeat(${gridSize}, 50px)`;

                let interval = setInterval(() => {
                    if (step >= path.length) {
                        clearInterval(interval);
                        return;
                    }
                    drawGrid("pathGrid", gridData);
                    let [row, col] = path[step];
                    let cell = document.querySelector(
                        `#pathGrid .cell:nth-child(${row * gridSize + col + 1})`
                    );
                    cell.classList.add("current");
                    step++;
                }, 500);
            }

            function getArrowSymbol(action) {
                return (
                    { up: "‚Üë", down: "‚Üì", left: "‚Üê", right: "‚Üí" }[action] || ""
                );
            }
        </script>
    </body>
</html>
